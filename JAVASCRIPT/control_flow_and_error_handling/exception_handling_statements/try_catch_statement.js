#!/usr/bin/node

/*
 * The try ..... catch statement marks a block of statements to try,
 * then we specify one or more responses should an exception be thrown.
 * If an exception is thrown, the try...catch statement catches it.
 *
 * Try block -> contains one or more statements.
 * Catch block -> contains statements that specify what to do should if an exception is thrown in the try block.
 *
 * In short, you want the try block to succeed.
 * If it does not, then control passes to the catch block.
 *
 * If any statement within the try block,
 * or in a function called from within the try block, throws an exception, 
 * control immediately shifts to the catch block.
 *
 * But if no exception is thrown in the try block,
 * the catch block is skipped.
 * Finally block executes after the try and catch blocks execute, and before the statements following the try..catch statement.
 */



// In the following example, a function is called that retrieves a month name from an array based on the value passed to the function.
//
// If the value passed does not correspond to any month, ( 1 - 12), an exception
// is thrown with the value "InvalidMonthNo".
// The statements in the catch block set the monthName variable to unknown.
//


function getMonthName(mo) {
	mo--; // adjust month number provided to match array index. ie 0 for Jan, 11 for Dec.
	

	const months = ['Jan', 'Feb', 'March', 'April', 'May', 'June', 'July', 'August', 'Sep', 'Oct', 'Nov', 'Dec'];

	if (months[mo]) {
		return months[mo];
	} else {
		throw new Error("InvalidMonthNo.");
	}
	
}

// console.log(getMonthName(5));

function logMyErrors(e) {
	console.log("Exception caught:" + e.toString()); // string representation of the error object.
	console.log(e); // More detailed information about the error.
}
try {
	let monthName = getMonthName(15);
	console.log(monthName);
} catch (error) {
	monthName = "Unknown."
	console.log(monthName);
	logMyErrors(error); // pass the exception object to error handler.
}

// The catch block.
// Use a catch block to handle all exceptions that may be generated in the try block.
// that is:
// 	catch (exception) {
// 		statements;
// 	}
//
// The identifier -> exception -> holds the value specified by the throw statement.
// Use this identifier to get information about the exception thrown.
// JS creates this identifier when the catch block is entered.
// This identifier lasts only for the duration of the catch block.
// Once the catch block finishes executing, the identifier no longer exists.
//
try {
	throw "My Exception";
} catch (exception) {
	logMyErrors(exception);
}


// NOTE:
// When logging errors to console inside a catch block, use console.error() for debugging.
// This formats the message as an error, and adds it to the list of error messages generated by the page.


try {
	throw "Exception.";
} catch (e) {
	console.error(e);
}



/*
 * FINALLY BLOCK
 * -------------
 *  Contains statements to be executed after the try and catch blocks execute.
 *  Finally block executes before the code that comes after the try...catch..finally statements.
 *
 *  Note the finally block will execute whether or not an exception is thrown.
 *  If an exception is thrown, the statements in the finally block execute even if no catch block handles the exception that was thrown.
 *  Use finally to make your script fail gracefully when an exception occurs.
 *  For ex to release a resource that your script has tied up.
 *
 *  	Opens a file.
 *  	Executes statements that use the file.
 *  		(Server-side JS allows you to access files).
 *  	If any exception is thrown while the file is open,
 *  	the finally block closes the file, before the script fails.
 *  	Using finally ensures the file is never left open, even if an error occurs.
 */

/*
 * openMyFile();
 *
 * try {
	writeMyFile(Data);
} catch (e) {
	handleError(e);
} finally {
	closeMyFile();
}



 * If the finally block returns a value,
 * that value becomes the return value of the entire try..catch..finally statement,
 * regardless of any return statements in the try and catch blocks.
 *
 */

function f() {
	try {
		console.log(0);
		throw "bogus";
	} catch (e) {
		console.log(1);
		return true;
		console.log(2);
	} finally {
		console.log(3);
		return false;
		console.log(4);
	}
	console.log(5);
}

console.log(f());

/*
 * Overwriting of return values by the finally block also apply to exceptions thrown or rethrown in the catch block.
 */


function g() {
	try {
		throw "so bogus";
	} catch (e) {
		console.log("Caught inner bogus: " + e.toString());
		throw e;
	} finally {
		// return false; // overwrites the previous throw.
		console.log("Removing return value");
		return true; // overwrites previous throw again.
	}
}

try {
	console.log(g());
} catch (e) {
	// this exception is overwritten by the return value of finally block
	console.log("This is never reached.");
}





// nested try...catch blocks
// -------------------------
// You can nest one or more try...catch statements.
//
// 	if an inner try block does not have a corresponding catch block =>
// 		It must contain a finally block,
// 		And the enclosing try...catch statement's catch block is checked for a match.
//
// Example:

try {
	try {
		throw new Error("Oopppsss");
	} catch (exception) { // if we had an inner catch block to handle the exception thrown in the inner try block.
		console.log(`Caught inner exception -> Error caught: ${exception.message}`);
		// let us now rethrow the exception
		throw exception;
	} finally {
		console.log("Must have a finally or catch block.");
	}
} catch (exception) {
	console.log("The outer catch block -> Error caught: " + exception.message);
}

// hence any given exception will be caught only once by the nearest enclosing catch block unless it is rethrown.
// Any new exceptions raised in the inner block, for ex thrown in the inner catch block, will be caught by the outer block.



/*
 * UTILIZING ERROR OBJECTS
 * ------------------------
 *  You can use the name and message properties
 *  
 *  name property -> provides the general class of Error: DOMException, Error
 *  message property -> provides a more succinct message compared to converting the error object to a string.
 *
 *  If you are throwing your own exceptions, 
 *  inorder to have access to these properties,
 *  use the Error constructor.
 */


let x = 10;


function doSomething() {
	if (x < 20) {
		throw new Error("x is less than 20");
	} else {
		console.log("Pass.")
	}
}

try {
	doSomething();
} catch (e) {
	console.log(e.name);
	console.log(e.message);
}
